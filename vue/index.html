<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue test</title>
</head>

<body>
  <div id="app"></div>
  <script src="https://cdn.bootcss.com/vue/2.4.4/vue.js"></script>
  <script>
    new Vue({
      data() {
        return {
          item: [0, 1, 2, 3, 4, 5, 6],
          blogTitle: 'hello, vie'
        }
      },
      created() {
        console.log('%cthis has created', 'color: blue')
        this.item.push(7) // 这里更新 this.item，并不会触发 updated 钩子；但会触发 watch 里的绑定的函数
        console.log(this.item)
      },
      mounted() {
        console.log('this has mounted')
        this.add() // 这里更新 this.item 也并不会触发 updated 钩子；但会触发 watch 里的绑定的函数；然而 watch 里的钩子会在多次更新以后，获取最后的更新值，并不会每次更新都获取值。
        console.log(this.item)
      },
      watch: {
        item: (newItem) => {  // 引用传递，改变 newItem ，也会更新 this.item，然后触发 updated 钩子；这会造成一个无限循环；watch 似乎在多次修改后的最后一次才会触发
          console.log('%c item has changed', 'color: red')
          console.log(newItem)
          // newItem.push(8)
          // console.log(this) // window
        }
      },
      updated() {
        console.log('%c this has updated', 'color: green')
      },
      methods: {
        add() {
          const len = this.item.length
          this.item[len] = this.item[len - 1] + 1
        }
      },
      render: function (createElement) {
        this.blogTitle = 'hello, VUE'
        this.add()
        return createElement('h1', this.blogTitle)
      }
    }).$mount('#app')
  </script>
</body>

</html>
